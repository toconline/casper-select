<!--
  - Copyright (c) 2014-2016 Cloudware S.A. All rights reserved.
  -
  - This file is part of casper-select.
  -
  - casper-select is free software: you can redistribute it and/or modify
  - it under the terms of the GNU Affero General Public License as published by
  - the Free Software Foundation, either version 3 of the License, or
  - (at your option) any later version.
  -
  - casper-select  is distributed in the hope that it will be useful,
  - but WITHOUT ANY WARRANTY; without even the implied warranty of
  - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  - GNU General Public License for more details.
  -
  - You should have received a copy of the GNU Affero General Public License
  - along with casper-select.  If not, see <http://www.gnu.org/licenses/>.
  -
-->
<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../iron-fit-behavior/iron-fit-behavior.html">
<link rel="import" href="../iron-overlay-behavior/iron-overlay-behavior.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../casper-icons/casper-icons.html">
<link rel="import" href="casper-select-dropdown.html">

<dom-module id="casper-select">
  <template>
    <style>
      :host {
        display: inline-block;
      }

      #dropdown {
        overflow: hidden;
        padding: 4px;
        border-radius: 0 0 3px 3px;
        border: 1px solid #aaa;
        background-color: white;
        display: flex;
        flex-direction: column;
        max-height: 99vh;
        box-shadow: rgba(25, 59, 103, 0.05) 0px 0px 0px 1px,
                    rgba(28, 55, 90, 0.16) 0px 2px 6px -1px,
                    rgba(28, 50, 79, 0.38) 0px 8px 24px -4px;
      }

       #listScroller {
        overflow: auto;
        -ms-overflow-style: -ms-autohiding-scrollbar;
        max-height: var(--casper-combo-box-overlay-max-height, 80vh);

        /* Fixes item background from getting on top of scrollbars on Safari */
        transform: translate3d(0,0,0);

        /* Enable momentum scrolling on iOS (iron-list v1.2+ no longer does it for us) */
        -webkit-overflow-scrolling: touch;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        flex-grow: 1;
      }

      #itemsList {
        @apply --casper-select-itemsList;
      }

      .listItem {
        margin: 0;
        overflow: hidden;
        line-height: 20px;
        white-space: nowrap;
        padding: 3px 7px 4px;
        box-sizing: border-box;
        background-color: white;
        @apply --casper-select-listItem;
      }

      .listItem:not(.itemDisabled):hover {
        color: white;
        background-color: var(--primary-color);
        @apply --casper-select-listItem-hover;
      }

      .listItem .highlight {
        border: 1px solid #ccc;
        font-weight: bold;
        border-radius: 4px;
        @apply --casper-select-listItem-highlight;
      }

      .listItem.itemSelected {
        color: white;
        background-color: #007e8e;
        @apply --casper-select-listItem-selected;
      }

      .listItem::before {
        width: 15px;
        content: "";
        margin-right: 5px;
        text-align: center;
        display: inline-block;
      }

      .listItem.itemSelected::before {
        content: "\2714";
      }

      .listItem.itemSelected:hover {
        color: white;
        background-color: #007e8e;
        @apply --casper-select-listItem-selected-hover;
      }

      .listItem.itemDisabled {
        background-color: #dedede;
        color: #00000033;
        cursor: not-allowed;
        @apply --casper-select-listItem-disabled;
      }

      #noResults {
        text-align: center;
        @apply --casper-select-list-no-results;
      }

      #searchSelf {
        width: auto;
      }

      #suffixIcon {
        cursor: pointer;
      }

      #dynamicListWithInput {
        list-style-type: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-wrap: wrap;
        flex-direction: row;
        background-color: white;
        border: none;
      }

      #dynamicListWithInput li:not(.input) {
        padding: 0 5px;
        margin: 0 4px 4px 0;
        display: flex;
        align-items: center;
        justify-content: center;
        line-height: 13px;
        color: #333;
        cursor: default;
        border: 1px solid #6F6262;
        border-radius: 3px;
        user-select: none;
        outline: none;
      }

      #dynamicListWithInput.listDisabled li:not(.input) {
        color: #A6A6A6;
        border: 1px solid #ACACAC;
      }

      #dynamicListWithInput.listDisabled li:not(.input) button[data-key] {
        display: none;
      }

      #dynamicListWithInput li:not(.input) button {
        padding: 0;
        color: white;
        width: 15px;
        height: 15px;
        border: none;
        outline: none;
        cursor: pointer;
        background: none;
        margin-right: 5px;
        user-select: none;
        display: flex;
        align-items: center;
        flex-direction: column;
        justify-content: center;
        background-color: #9E9E9E;
        border-radius: 50%;
      }

      #dynamicListWithInput li:not(.input) button:hover {
        background-color: #686868;
      }

      #dynamicListWithInput li:not(.input) button iron-icon {
        width: 100%;
        height: 100%;
      }

      #dynamicListWithInput.multiSelectionWithTags {
        padding: 5px;
        border: 1px solid #e4e4e4;
      }

      #dynamicListWithInput.multiSelectionWithTags li {
        height: 25px;
      }

      #dynamicListWithInput:not(.multiSelectionWithTags) li:last-child {
        flex-grow: 1;
      }

      :root {
        --paper-input-container-color: white;
        --paper-input-container-invalid-color: green;

        --paper-input-container: {
          padding: 0;
          background-color: var(--primary-color);
        };
        --paper-input-container-input: {
          color: white;
        };
        --paper-input-prefix: {
          color: white;
          height: 18px;
        };
        --paper-input-suffix: {
          opacity: 0;
          color: white;
          height: 18px;
        };
      }

      #searchSelf {
        --paper-input-container-color: #6f6262;
        --paper-input-container-invalid-color: green;
        --paper-input-container: {
          background-color: white;
        };
        --paper-input-container-input: {
          color: black;
          text-overflow: ellipsis;
        };
        --paper-input-prefix: {
          color: white;
          height: 18px;
        };
        --paper-input-suffix: {
          color: #525252;
          height: 15px;
        };
      }

      #searchSelf.multiSelectionWithTags {
        --paper-input-container: {
          padding: 0;
        };
        --paper-input-container-underline: {
          display: none;
        };
        --paper-input-container-underline-focus: {
          display: none;
        };
      }
    </style>

    <template is="dom-if" if="[[ searchDynamic ]]">
      <ul id="dynamicListWithInput" class$="[[ multiSelectionTagsClass ]] [[ _computedDisabledSelect(disabled) ]]">
        <li class="input">
          <paper-input id="searchSelf"
            class$="paper-input [[ multiSelectionTagsClass ]]"
            no-label-float="[[ noLabelFloat ]]"
            label="[[ label ]]"
            on-tap="selfInputClicked">
            <template is="dom-if" if="[[!multiSelection]]">
              <iron-icon icon="casper-icons:arrow-drop-down" slot="suffix"></iron-icon>
            </template>
          </paper-input>
        </li>
      </ul>
    </template>
    <casper-select-dropdown id="dropdown" no-overlap dynamic-align horizontal-align="auto" vertical-align="auto" no-cancel-on-esc-key>
      <slot name="search"></slot>
      <template is="dom-if" if="[[ searchCombo ]]">
        <paper-input tabindex="1" id="searchInput" class="paper-input" no-label-float label="pesquisar..">
          <iron-icon class="iron-icon" icon="casper-icons:search" slot="prefix"></iron-icon>
          <iron-icon id="suffixIcon" class="iron-icon" icon="casper-icons:clear" slot="suffix" alt="limpar" title="limpar"></iron-icon>
        </paper-input>
      </template>
      <div id="listScroller">
        <iron-list id="itemsList"
          class$="[[ _computedDisabledSelect(disabled) ]]"
          scroll-target="listScroller"
          items="[[ filteredItems ]]"
          selected-items="{{ ironListSelectedItems }}">
          <template>
            <div on-tap="_itemClicked">
              <div class$="listItem [[ _computedItemSelectedClass(selected, index) ]] [[ _computedItemDisabledClass(item.csDisabled) ]]"
                style$="[[ listItemHeightStyle ]]"
                inner-h-t-m-l="[[ _computedItemHtml(item._csHTML) ]]">
              </div>
            </div>
          </template>
        </iron-list>
        <template is="dom-if" if="[[ noVisibleItems ]]">
          <div id="noResults">[[ emptyList ]]</div>
        </template>
      </div>
      <slot name="status"></slot>
    </casper-select-dropdown>
  </template>
  <script>
    "use strict";

    class CasperSelect extends Polymer.Element {

      static get is () {
        return 'casper-select';
      }

      static get properties () {
        return {
          /**
           * Items supplied
           * @type {Object}
           */
          items: {
            type: Object,
            observer: '_itemsChanged'
          },
          /**
           * Disabled Items Stored
           * @type {Object}
           */
          disabledItems: {
            type: Object,
            observer: '_disabledItemsChanged',
            value: () => []
          },
          /**
           * Disabled Items Keys Stored
           * @type {Array}
           */
          disabledItemsKeys: {
            type: Array,
            value: () => []
          },
          /**
           * Item Column -> default: "name"
           * @type {String}
           */
          itemColumn: {
            type: String,
            value: 'name'
          },
          /**
           * Key Column -> default: "id"
           * @type {String}
           */
          keyColumn: {
            type: String,
            value: 'id'
          },
          /**
           * Multi Selection Key Values Seperator
           * @type {Object}
           */
          multiSelectionValueSeperator: {
            type: String,
            value: ','
          },
          /**
           * Initial ID to be compared to "keyColumn" for initial selection
           * @type {Object}
           */
          initialId: {
            type: Object
          },
          /**
           * Dynamic Search Input - Internal Paper Input Property
           * @type {Boolean}
           */
          noLabelFloat: {
            type: Boolean,
            value: false
          },
          /**
           * Dynamic Search Innput - Internal Paper Input Property
           * @type {String}
           */
          label: {
            type: String,
            value: 'Escolha uma opção'
          },
          /**
           * Empty List String
           * @type {String}
           */
          emptyList: {
            type: String,
            value: 'Lista vazia'
          },
          /**
           * Items actually present in the select
           * @type {Object}
           */
          filteredItems: {
            type: Object,
            value: () => []
          },
          /**
           * This option doesn't allow you to enter search terms that have no matches
           * Either shows matched or prevents your input
           * @type {Boolean}
           */
          smartFilter: {
            type: Boolean,
            value: true
          },
          /**
           * Activate or disable filtering
           * @type {Boolean}
           */
          filtering: {
            type: Boolean,
            value: true
          },
          /**
           * No visible items COMPUTED flag
           * smartFilter needs to be disabled for this value to become true
           * @type {Boolean}
           */
          noVisibleItems: {
            type: Boolean,
            value: false,
            computed: '_emptyList(filteredItems)'
          },
          /**
           * Iron List Internal Selected Items - DO NOT MANIPULATE
           * @type {Object}
           */
          ironListSelectedItems: {
            type: Object
          },
          /**
           * Casper-Select Internal Selected Items
           * DO NOT MANIPULATE
           * @type {Object}
           */
          _selectedItems: {
            type: Object,
            observer: '_selectedItemsChanged'
          },
          /**
           * Casper-Select Internal Last Selected Items
           * DO NOT MANIPULATE
           * @type {Object}
           */
          lastSelectedItems: {
            type: Object,
            value: () => []
          },
          /**
           * Casper-Select current option stringified
           * @type {String}
           */
          value: {
            type: String,
            notify: true
          },
          /**
           * HTML Template for the items, with curly brackets for object value replacement
           * @type {String}
           */
          template: {
            type: String
          },
          /**
           * CSS Styling for the HTML Template that overrides
           * @type {Object}
           */
          templateStyle: {
            type: String,
            observer: '_templateStyleChanged'
          },
          /**
           * Template height per item in px
           * @type {Number}
           */
          listItemHeight: {
            type: Number,
            value: 27
          },
          /**
           * Template width per item in px
           * List Width = This value * Longest Item String
           * @type {Number}
           */
          listItemWidth: {
            type: Number,
            value: 20
          },
          /**
           * Template style override to enforce height - COMPUTED
           * @type {String}
           */
          listItemHeightStyle: {
            type: String,
            computed: '_listItemHeightDefined(listItemHeight)'
          },
          /**
           * Disable the entire select
           * @type {Object}
           */
          disabled: {
            type: Boolean,
            value: false,
            observer: '_selectDisabled'
          },
          /**
           * If multi-selection should be enabled
           * @type {Boolean}
           */
          multiSelection: {
            type: Boolean,
            value: false,
            observer: '_multiSelectionChanged'
          },
          /**
           * Use multi-selection tags on the input
           * Requires: "searchDynamic" to be true
           * @type {Boolean}
           */
          multiSelectionTags: {
            type: Boolean,
            value: false
          },
          /**
           * Computed property to hold the multi-selection tags class to add to the DOM
           * @type {String}
           */
          multiSelectionTagsClass: {
            type: String,
            computed: '_multiSelectionTagsDefined(multiSelectionTags)'
          },
          /**
           * DOM Element provided to override the placeholder for the multi-selection tags
           * @type {Object}
           */
          multiSelectionTagsElementParent: {
            type: Object
          },
          /**
           * Enable or disable selections
           * @type {Boolean}
           */
          selectionEnabled: {
            type: Boolean,
            value: true,
            observer: '_selectionEnabledChanged'
          },
          /**
           * When attached to an existing element, will use that same element for filtering
           * @type {Boolean}
           */
          searchInline: {
            type: Boolean,
            value: false,
            observer: '_searchInlineChanged'
          },
          /**
           * When attached to an existing element, will add an extra input to the "select dropdown" for filtering
           * @type {Object}
           */
          searchCombo: {
            type: Boolean,
            value: false,
            observer: '_searchComboChanged'
          },
          /**
           * Dynamically shows its own input, and uses it for filtering and for showing the selected option
           * Is also computed by the other two types of searches
           * @type {Object}
           */
          searchDynamic: {
            type: Boolean,
            value: false,
            computed: '_isDynamicSearch(searchInline, searchCombo)',
            observer: '_searchDynamicChanged'
          },
          /**
           * If we are not in "multiSelcetion" mode, will automatically close dropdown on select
           * @type {Boolean}
           */
          closeOnSelect: {
            type: Boolean,
            value: true
          },
          /**
           * HTML Tag that embodies the Highlighted text
           * Default: span
           * @type {String}
           */
          highlightTemplateTag: {
            type: String,
            value: 'span'
          },
          /**
           * CSS class applied to the Highlight Template Tag
           * @type {String}
           */
          highlightTtemplateClass: {
            type: String,
            value: 'highlight'
          },
          /**
           * Target element (if using exisitng input elements on the page) to attach the select dropdown to
           * @type {Object}
           */
          targetElement: {
            type: Object,
            observer: '_targetElementChanged'
          },
          /**
           * Fixed List Height
           * @type {String}
           */
          listHeight: String,
          /**
           * Fied List Width
           * @type {String}
           */
          listWidth: String,
          /**
           * Enforce select width to match container width
           * @type {Object}
           */
          fixedContainerWidth: {
            type: Boolean,
            value: false
          },
          /**
           * Adjust list height when filtering results
           * @type {Boolean}
           */
          resizeOnFilter: {
            type: Boolean,
            value: true
          },
          /**
           * Current status of the dropdown
           * @type {Boolean}
           */
          opened: {
            type: Boolean,
            value: false
          },
          /**
           * Resets filtering and search term on a new attachment
           * @type {Boolean}
           */
          resetOnOpen: {
            type: Boolean,
            value: false
          }
        };
      }

      ready () {
        super.ready();

        this._boundDebounceFilterItems = this._debounceFilterItems.bind(this);
        this._boundSearchInputKeyDownHandler = this._searchInputKeyDownHandler.bind(this);
        this._boundSearchInputKeyPressHandler = this._searchInputKeyPressHandler.bind(this);
        this._boundClearSearch = this._clearSearch.bind(this);

        this.$.dropdown.addEventListener('opened-changed', e => this._onOpenedChanged(e));
        this.$.dropdown.addEventListener('iron-overlay-canceled', e => this._cancelOverlay(e));

        window.select = this;
      }

      _cancelOverlay (e) {
        if  ( e.detail.path.includes(this.searchInput) ) {
          e.preventDefault();
        }
      }

      _onOpenedChanged (e) {
        // Closing
        if ( e.detail.value === false ) {
          this.opened = false;
          if ( !this.multiSelection && ( this.searchDynamic || this.searchInline ) ) {
            this.lastSelectedItems = this._selectedItems;
            if ( this._selectedItems !== undefined ) {
              this._setValueInInput();
            } else {
              this._clearValueInput();
            }
          }
        // Opening
        } else {
          if ( typeof this._selectedIndex !== "undefined" ) {
            setTimeout(() => {
              this.$.itemsList.scrollToIndex( this._selectedIndex );
            }, 16);
          }
          this.opened = true;
          if ( !this.multiSelection && ( this.searchDynamic || this.searchInline ) ) {
            this._unsetValueInInput();
          }
        }
      }

      _clearValueInput () {
        this.searchInput.value = "";
      }

      _setValueInInput () {
        this._tempFiltering = this.filtering;
        this.filtering = false;
        this.searchInput.value = this._selectedItems[this.itemColumn];
        this.searchInput.setAttribute('readonly', '');
      }

      _unsetValueInInput() {
        this.searchInput.value = "";
        this.searchInput.removeAttribute('readonly');
        this._resizeItemListHeight();
        if ( typeof this._tempFiltering !== "undefined" ) {
          this.filtering = this._tempFiltering;
        }
      }

      _isDynamicSearch ( searchInline, searchCombo ) {
        return ( searchInline === false && searchCombo === false );
      }

      _searchDynamicChanged ( newSearchDynamicValue, oldSearchDynamicValue ) {
        if ( newSearchDynamicValue && !oldSearchDynamicValue ) {
          Polymer.RenderStatus.afterNextRender(this.shadowRoot.querySelector('#searchSelf'), () => {
            if ( this.items && this.items.length > 0 ) {
              this._resizeItemListHeight();
            }
            this._setMultiSelectionTarget();
            this._unbindSearchInputListeners();
            this.searchInput = this.targetElement;
            this._bindSearchInputListeners();
          });
        }
      }

      _selectedItemsChanged ( newSelectedItems ) {
        let list = this.multiSelectionTagsElementParent ? this.multiSelectionTagsElementParent : this.shadowRoot.querySelector('#dynamicListWithInput');
        if ( this.multiSelection && this.multiSelectionTags ) {
          if ( list ) {
            this._removeDynamicListSelectedValues(list);
            if ( newSelectedItems !== undefined && newSelectedItems.length > 0 ) {
              newSelectedItems.forEach( el => {
                const li = document.createElement('li');
                const liButton = document.createElement('button');
                const liSpan = document.createElement('span');

                const liButtonIcon = document.createElement('iron-icon');
                liButtonIcon.setAttribute('icon', 'casper-icons:clear');

                liButton.appendChild(liButtonIcon);
                liButton.dataset.key = el[this.keyColumn];
                liButton.addEventListener('click', this._removeOptionFromList.bind(this));
                liSpan.innerHTML = el[this.itemColumn];
                li.appendChild(liButton);
                li.appendChild(liSpan);
                list.insertBefore(li, list.lastElementChild);
              });
            }
          }
          this.$.dropdown.refit();
        } else {
          if ( list ) {
            this._removeDynamicListSelectedValues(list);
            this.$.dropdown.refit();
          }
        }

        this._setValue();
        if ( !this.disabled ) {
          this.dispatchEvent(new CustomEvent('value-changed', { detail: { selectedItems: newSelectedItems } }));
        }
      }

      _removeDynamicListSelectedValues( list ) {
        let elements = this.multiSelectionTagsElementParent ? list.querySelectorAll('li') : list.querySelectorAll("li:not(:last-child)");
        if ( elements.length > 0 ) {
          [...elements].forEach( el => {
            list.removeChild(el);
          });
        }
      }

      _removeOptionFromList (event) {
        const clickedKey = event.target.parentNode.dataset.key;

        for ( let [key, item] of Object.entries(this._selectedItems) ) {
          if ( item[this.keyColumn] == clickedKey ) {
            this._selectedItems.splice(key, 1);
            this._selectedItems = JSON.parse(JSON.stringify( this._selectedItems ));
            break;
          }
        }
        for ( let [key, item] of Object.entries(this.ironListSelectedItems) ) {
          if ( item[this.keyColumn] == clickedKey ) {
            this.$.itemsList.deselectItem( item );
            break;
          }
        }
        this.$.dropdown.refit();
        event.preventDefault();
        event.stopPropagation();
      }

      selfInputClicked () {
        if ( this.items && this.items.length > 0 && !this.disabled ) {
          if ( !this.opened ) {
            this.openDropdown();
          }
        } else {
          this.searchInput.blur();
        }
      }

      _itemClicked (e) {

        let classList = e.target.classList;

        if ( !this.selectionEnabled || classList.contains("itemDisabled") ) {
          e.preventDefault();
          e.stopPropagation();
          return;
        }

        if ( !this._selectedItems || this._selectedItems.length === 0 ) {
          this._selectedItems = [];
        }

        if ( this.multiSelection ) {
          if ( classList.contains("itemSelected") ) {
            for ( let [key, item] of Object.entries(this._selectedItems) ) {
              if ( item[this.keyColumn] == e.model.item[this.keyColumn] ) {
                this._selectedItems.splice(key, 1);
                this._selectedItems = JSON.parse(JSON.stringify( this._selectedItems ));
                return;
              }
            }
          } else {
            if ( typeof this._selectedItems === "undefined" ) {
              this._selectedItems = [];
            }
            this._selectedItems.push(e.model.item);
            this._selectedItems = JSON.parse(JSON.stringify( this._selectedItems ));
          }
        } else {
          if ( classList.contains("itemSelected") ) {
            this._selectedItems = [];
            this._selectedIndex = -1;
          } else {
            this._selectedIndex = e.model.index;
            this._selectedItems = e.model.item;
            if ( this.closeOnSelect ) {
              this.closeDropdown();
            }
          }
        }
      }

      _emptyList (items) {
        return !items || items.length === 0 ? true : false;
      }

      _clearSearch () {
        this.searchInput.value = "";
        this.shadowRoot.querySelector("#suffixIcon").style.opacity = 0;
        this.shadowRoot.querySelector("#suffixIcon").removeEventListener('click', this._boundClearSearch);
      }

      _searchInputKeyPressHandler (event) {

        if ( !this.smartFilter || !this.filtering || !this.searchInput ) {
          return;
        }

        let key = event.keyCode || event.which;
        if (key == 13)
          return;

        let nextLetter = String.fromCharCode(key);
        if (nextLetter.length > 0) {
          let searchTerm = this.searchInput.value + nextLetter.trim();
          if (searchTerm.length > 0) {
            let _lastQuery = this.searchInput.value;
            this.filterItems(searchTerm);
            if (this.filteredItems.length === 0) {
              event.preventDefault();
              this.filterItems(_lastQuery);
            }
          }
        }
      }

      _searchInputKeyDownHandler (event) {
        let key = event.keyCode || event.which;
        switch (key) {
          case  9: // tab
          case 13: // enter
            this._closingKey = key == 13 ? 'enter' : (event.shiftKey === true ? 'shift+tab' : 'tab');
            if ( !this.multiSelection ) {
              this.lastSelectedItems = this._selectedItems;
              if ( this.opened ) {
                if ( this.closeOnSelect ) {
                  this.closeDropdown();
                }
              } else {
                if ( this.searchInput ) {
                  this.searchInput.blur();
                }
              }
            }
            break;
          case 27: // escape
            this._closingKey = 'esc';
            if ( !this.multiSelection ) {
              this._selectedItems = this.lastSelectedItems;
              this.ironListSelectedItems = [];
              this.ironListSelectedItems = this._selectedItems;
              if ( this._selectedItems === undefined ) {
                this._clearValueInput();
              } else {
                this._setValueInInput();
              }
            }
            if ( this.opened ) {
              this.closeDropdown();
            } else {
              if ( this.searchInput ) {
                this.searchInput.blur();
              }
            }
            break;
          case 37: // left
            if ( this._doesntExistYet ) {
              this._moveSelection('up');
            }
            break;
          case 38: // up
            this._moveSelection('up');
            event.stopPropagation();
            break;
          case 39: // right
            if ( this._doesntExistYet ) {
              this._moveSelection('down');
            }
            break;
          case 40: // down
            this._moveSelection('down');
            event.stopPropagation();
            break;
          default:
            event.stopPropagation();
            return;
        }
      }

      _moveSelection (direction) {
        if ( !this.multiSelection ) {
          let _selectedIndex = typeof this._selectedIndex === "undefined" || isNaN(this._selectedIndex) ? -1 : this._selectedIndex;
          let indexScroll = _selectedIndex;
          if ( direction === 'up' && _selectedIndex > 0 ) {
            _selectedIndex -= 1;
            indexScroll = _selectedIndex - 1;
          } else if ( direction === 'down' && _selectedIndex < this.filteredItems.length - 1 ) {
            _selectedIndex += 1;
            indexScroll = _selectedIndex - 1;
          }

          this.$.itemsList.selectItem( this.$.itemsList.items[_selectedIndex] );
          this._selectedIndex = _selectedIndex;
          this._selectedItems = this.$.itemsList.items[_selectedIndex];
          this.$.itemsList.scrollToIndex( indexScroll );

          if ( !this.opened ) {
            this._setValueInInput();
          }

        }
      }

      _targetElementChanged ( newTargetElement ) {
        if ( typeof newTargetElement === "object" && this.searchInline === true ) {
          this._unbindSearchInputListeners();
          this.searchInput = this.targetElement;
          this._bindSearchInputListeners();
        }
      }

      _bindSearchInputListeners () {
        if ( this.searchInput ) {
          if ( this.disabled ) {
            this.searchInput.setAttribute('disabled', '');
          }
          this._unbindSearchInputListeners();
          this.searchInput.addEventListener('value-changed', this._boundDebounceFilterItems);
          this.searchInput.addEventListener('keydown', this._boundSearchInputKeyDownHandler);
          this.searchInput.addEventListener('keypress', this._boundSearchInputKeyPressHandler);
        }
      }

      _unbindSearchInputListeners () {
        if ( this.searchInput ) {
          this.searchInput.removeEventListener('value-changed', this._boundDebounceFilterItems);
          this.searchInput.removeEventListener('keydown', this._boundSearchInputKeyDownHandler);
          this.searchInput.removeEventListener('keypress', this._boundSearchInputKeyPressHandler);
        }
      }

      _searchComboChanged ( newSearchComboValue, oldSearchComboValue ) {
        if ( newSearchComboValue && !oldSearchComboValue ) {
          this.searchInline = false;
          Polymer.RenderStatus.afterNextRender(this.shadowRoot.querySelector('#searchInput'), () => {
            this.searchInput = this.shadowRoot.querySelector('#searchInput');
            this._bindSearchInputListeners();
          });
          Polymer.RenderStatus.afterNextRender(this.shadowRoot.querySelector("#suffixIcon"), () => {
            this.shadowRoot.querySelector("#suffixIcon").addEventListener('click', this._boundClearSearch);
          });
        } else if ( newSearchComboValue === false && oldSearchComboValue === true ) {
          this._unbindSearchInputListeners();
        }
      }

      _searchInlineChanged ( newSearchInlineValue, oldSearchInlineValue ) {
        if ( newSearchInlineValue && !oldSearchInlineValue ) {
          this.searchCombo = false;
          this.searchInput = this.targetElement;
          this._bindSearchInputListeners();
        } else if ( newSearchInlineValue === false && oldSearchInlineValue !== newSearchInlineValue ) {
          this._unbindSearchInputListeners();
        }
      }

      _templateStyleChanged ( newTemplateStyle ) {
        const shadowRoot = this.shadowRoot;
        if ( shadowRoot.querySelector('#templateStyle') ) {
          shadowRoot.querySelector('#templateStyle').remove();
        }
        if ( newTemplateStyle !== undefined ) {
          const templateStyle = document.createElement('style');
          templateStyle.setAttribute('id', 'templateStyle');
          templateStyle.textContent = newTemplateStyle;
          shadowRoot.appendChild(templateStyle);
        }
      }

      _itemsChanged ( newItems ) {
        if ( newItems && newItems.length > 0 && newItems[0].constructor === String) {
          let itemsConvertedToObject = [];
          newItems.forEach( (element, index) => itemsConvertedToObject.push({id: index, name: element}));
          // The following object change will trigger the observer again, so we do an early return
          this.items = itemsConvertedToObject;
          return;
        }
        if ( this.template && this.items.length > 0 ) {
          let found = [], rxp = /\{([^}]+)\}/g, curMatch;
          while ( (curMatch = rxp.exec( this.template )) ) {
            found.push( curMatch[1] );
          }
          this._templateToReplace = found;
        }

        for ( let [key, item] of Object.entries(this.items) ) {
          if ( this.template && this._templateToReplace !== undefined ) {
            let mapping = {};
            this._templateToReplace.forEach(e => mapping[`{${e}}`] = item[e]);
            item._csHTML = this.template.replace(/\{\w+\}/ig, n => mapping[n]);
          } else {
            item._csHTML = item[this.itemColumn];
          }
          this.items[key] = item;
        }
        if ( !this.filtering ) {
          this.filteredItems = this.items;
        }

        if ( this.items.length > 0 ) {
          this.filterItems(undefined, true);
          Polymer.RenderStatus.afterNextRender(this.searchInput, () => {
            this._resizeItemListHeight();
            this._resizeItemListWidth();
          });
          if ( typeof this._ignoreDisabledItems === "undefined" || this._ignoreDisabledItems === false ) {
            const currentDisabledItemsKeys = this.disabledItemsKeys;
            this.disabledItems = this.disabledItemsKeys = [];
            this.disableItems( currentDisabledItemsKeys );
          }
        } else {
          if ( typeof this._ignoreDisabledItems === "undefined" || this._ignoreDisabledItems === false ) {
            Polymer.RenderStatus.afterNextRender(this.searchInput, () => {
              this._unsetValueInInput();
            });
          }
        }
      }

      enableItems ( enabledItemsKeys ) {
        this.disableItems( this.disabledItemsKeys.filter(key => !enabledItemsKeys.includes(key)), true );
      }

      disableAllItems () {
        this.disableItems ( [], false, true );
      }

      disableItems ( disabledItemsKeys, cleanPrevious = false, disableAll = false ) {
        let disabledItemsLength = disabledItemsKeys.length;
        let disabledItemsFound = 0;
        if ( disabledItemsLength > 0 ) {
          disabledItemsKeys = disabledItemsKeys.filter(key => !this.disabledItemsKeys.includes(key));
          disabledItemsLength = disabledItemsKeys.length;
        }
        if ( disabledItemsLength > 0 || cleanPrevious || disableAll ) {
          this.disabledItemsKeys = disabledItemsKeys;
          let items = [], disabledItems = [];
          for ( let [key, item] of Object.entries(this.items) ) {
            let newItem = JSON.parse(JSON.stringify( item ));
            if ( cleanPrevious ) {
              newItem.csDisabled = false;
            } else if ( disableAll ) {
              newItem.csDisabled = true;
            }
            if ( disabledItemsLength > 0 && disabledItemsFound < disabledItemsLength ) {
              for ( let disabledItemKey of disabledItemsKeys ) {
                if ( item[this.keyColumn] == disabledItemKey ) {
                  newItem.csDisabled = true;
                  disabledItemsFound++;
                  break;
                }
              }
            }
            if ( newItem.csDisabled ) {
              disabledItems.push({ index: key, key: item[this.keyColumn] });
            }
            items.push(newItem);
          }
          this.disabledItems = disabledItems;
          this._ignoreDisabledItems = true;
          this.items = [];
          this.items = items;
          this._ignoreDisabledItems = false;
          this.filterItems();
        }
      }

      deselectAllItems () {
        this._clearValueInput();
        this._tempItems = this.items;
        this.items = [];

        this._selectedItems = [];
        this.lastSelectedItems = [];
        this.ironListSelectedItems = [];
        this.items = this._tempItems;
        this._tempItems = undefined;
      }

      _disabledItemsChanged ( newDisabledItems ) {
        if ( newDisabledItems && newDisabledItems.length > 0 ) {
          if ( this.multiSelection ) {
            if ( this._selectedItems !== undefined ) {
              let selectedItems = [];
              for ( let [key, item] of Object.entries(this._selectedItems) ) {
                if ( !this.disabledItemsKeys.includes(item[this.keyColumn]) ) {
                  selectedItems.push(item);
                }
              }
              this._selectedItems = selectedItems;
            }
            if ( this.lastSelectedItems !== undefined ) {
              let lastSelectedItems = [];
              for ( let [key, item] of Object.entries(this.lastSelectedItems) ) {
                if ( !this.disabledItemsKeys.includes(item[this.keyColumn]) ) {
                  lastSelectedItems.push(item);
                }
              }
              this.lastSelectedItems = lastSelectedItems;
            }
          } else {
            if ( this._selectedItems !== undefined ) {
              if ( this.disabledItemsKeys.includes(this._selectedItems[this.keyColumn]) ) {
                this._selectedItems = undefined;
                if ( !this.opened ) {
                  this._clearValueInput();
                }
              }
            }
            if ( this.lastSelectedItems !== undefined ) {
              if ( this.disabledItemsKeys.includes(this.lastSelectedItems[this.keyColumn]) ) {
                this.lastSelectedItems = undefined;
              }
            }
          }
        }
      }

      _computedItemHtml (html) {
        this._debounceRender();
        return html;
      }

      _selectDisabled ( isSelectDisabled ) {
        if ( isSelectDisabled === true) {
          if ( this.searchInput ) {
            this.searchInput.setAttribute('disabled', '');
          }
          if ( this.opened ) {
            this.closeDropdown();
          }
        } else {
          if ( this.searchInput ) {
            this.searchInput.removeAttribute('disabled');
          }
        }

        this._setValue();
      }

      _multiSelectionChanged ( newMultiSelectionValue, oldMultiSelectionValue ) {
        if ( newMultiSelectionValue ) {
          this.$.itemsList.setAttribute('multi-selection', '');
          this._setMultiSelectionTarget();
        } else {
          this.$.itemsList.removeAttribute('multi-selection');
          this.multiSelectionTags = false;
        }
        this._selectedItems = [];
        this.lastSelectedItems = [];
      }

      _setMultiSelectionTarget () {
        if ( this.multiSelection ) {
          if ( !this.multiSelectionTagsElementParent ) {
            this.multiSelectionTags = true;
          }
          if ( this.multiSelectionTags ) {
            this._setPositionTarget(this.shadowRoot.querySelector('#dynamicListWithInput'));
          } else {
            this._setPositionTarget(this.shadowRoot.querySelector('#searchSelf'));
          }
        } else {
          this._setPositionTarget(this.shadowRoot.querySelector('#searchSelf'));
        }
      }

      _selectionEnabledChanged ( newSelectionEnabledValue ) {
        if ( newSelectionEnabledValue )  {
          this.$.itemsList.setAttribute('selection-enabled', '');
        } else {
          this.$.itemsList.removeAttribute('selection-enabled');
          this.ironListSelectedItems = null;
        }
      }

      _multiSelectionTagsDefined ( multiSelectionTags ) {
        this.noLabelFloat = multiSelectionTags;
        return multiSelectionTags ? 'multiSelectionWithTags' : '';
      }

      _listItemHeightDefined ( listItemHeight ) {
        return "height:" + listItemHeight + "px;";
      }

      _computedDisabledSelect ( disabled ) {
        return disabled ? 'listDisabled' : '';
      }

      _computedItemDisabledClass ( disabled ) {
        return disabled ? 'itemDisabled' : '';
      }

      _computedItemSelectedClass ( selected ) {
        if ( this.opened ) {
          this._debounceFocus();
        }

        return selected ? 'itemSelected' : '';
      }

      _debounceRender (defaultTimeout = 15) {
        if ( typeof this._debounceRenderTimeout !== "undefined" ) {
          clearTimeout(this._debounceRenderTimeout);
        }
        this._debounceRenderTimeout = setTimeout(() => {
          this._selectItems();
        }, defaultTimeout);
      }

      _debounceFocus (defaultTimeout = 15) {
        if ( !this.searchInput ) {
          return;
        }
        if ( typeof this._debounceFocusTimeout !== "undefined" ) {
          clearTimeout(this._debounceFocusTimeout);
        }
        this._debounceFocusTimeout = setTimeout(() => {
          this.searchInput.blur();
          this.searchInput.focus();
        }, defaultTimeout);
      }

      openDropdown () {
        this.$.dropdown.positionTarget = this.targetElement;
        this.$.dropdown.open();
      }

      closeDropdown () {
        this.$.dropdown.close();
      }

      attachTo (element, options) {

        if ( this.resetOnOpen ) {
          this._clearSearch();
          this.ironListSelectedItems = null;
          this.filteredItems = this.items;
          this._selectedItems = [];
        }

        if ( options !== undefined ) {
          for ( let [key, value] of Object.entries(options) ) {
            this.key = value;
          }
        }

        this._setPositionTarget(element);
        this._resizeItemListHeight();

        this.openDropdown();

        Polymer.RenderStatus.afterNextRender(this.searchInput, () => {
          this._debounceFocus(0);
        });
      }

      _setPositionTarget (element) {
        this.$.dropdown.positionTarget = element;
        this.targetElement = element;
        this._resizeItemListWidth();
      }

      _debounceFilterItems (event) {
        if ( typeof this._debounceFilterItemsTimeout === "undefined" ) {
          this.filterItems(event.detail.value);
          this._debounceFilterItemsTimeout = setTimeout(() => {}, 0);
          return;
        } else {
          clearTimeout(this._debounceFilterItemsTimeout);
        }
        this._debounceFilterItemsTimeout = setTimeout(() => this.filterItems(), 0);
      }

      filterItems (query, clearLast = false) {
        if ( typeof this.items === "undefined" || this.items.length === 0 || this.filtering === false ) {
          return;
        }

        if ( clearLast ) {
          this._lastQueryNormalized = this._lastQuery = undefined;
        }

        query = query || (this.searchInput ? this.searchInput.value : '');
        if ( query === this._lastQuery ) {
            return;
        }

        this._lastQuery = query;
        let filteredItems = [];

        let queryNormalized = (query.normalize('NFD').replace(/[\u0300-\u036f]/g, '')).toLowerCase().split(' ').filter((el) => el !== '');

        if ( typeof this._lastQueryNormalized !== "undefined" ) {
          if ( this._simpleArrayEqual(queryNormalized, this._lastQueryNormalized ? this._lastQueryNormalized : []) === true ) {
            return;
          }
        }

        if ( query !== '' ) {
          let highlightTemplate = this._highlightTemplate();

          this._lastQueryNormalized = queryNormalized;
          this.filteredItems = [];

          for ( let [key, item] of Object.entries(this.items) ) {
            let itemValue = item[this.itemColumn];
            let itemNormalized = itemValue.toString().normalize('NFD').replace(/[\u0300-\u036f]/g, "").toLowerCase();
            let modifications = [];

            for ( let term of queryNormalized ) {
              let indexOf = itemNormalized.indexOf(term);
              if ( indexOf !== -1 ) {
                modifications.push([indexOf, indexOf + term.length - 1]);
              }
            }

            if ( modifications.length > 0 && modifications.length == queryNormalized.length )  {
              modifications = this._mergeOverlappedRanges(modifications);
              let itemText = itemValue.substring(0, modifications[0][0]);
              for ( let m = 0; m < (modifications.length); m++ ) {
                itemText += highlightTemplate.begin + itemValue.substring(modifications[m][0], modifications[m][1] + 1) + highlightTemplate.end;
                if ( m === (modifications.length) - 1) {
                  itemText += itemValue.substring(modifications[m][1] + 1, itemValue.length);
                } else {
                  itemText += itemValue.substring(modifications[m][1] + 1, modifications[m+1][0]);
                }
              }
              let newItem = JSON.parse(JSON.stringify( item ));
              newItem["_csHTML"] = itemText;
              filteredItems.push(newItem);
            }
          }

          // @REVIEW:
          // This doesn't seem necessary nor important at this stage..
          // Dont remember why I added it, so I just commented it for now

          //if ( filteredItems.length === 0 ) {
            //this.searchInput.value = _lastQuery;
          //}
          this.filteredItems = [];
          this.filteredItems = filteredItems;
        } else {
          this._lastQueryNormalized = queryNormalized;
          this.filteredItems = [];
          this.filteredItems = this.items;
        }

        if ( this.resizeOnFilter ) {
          this._resizeItemListHeight();
        }

        try {
            this.shadowRoot.querySelector("#suffixIcon").style.opacity = this._lastQueryNormalized.length > 0 ? 1 : 0;
        } catch (e) {
          // Sometimes the #suffixIcon might not exist.
        }

      }

      _resizeItemListHeight (useFiltered = true) {
        let items = useFiltered ? this.filteredItems : this.items;
        if ( this.listHeight != undefined ) {
          this.$.itemsList.style.height = this.listHeight;
        } else {
          this.$.itemsList.style.height = (Object.keys(items).length * this.listItemHeight) + 'px';
        }
        if ( this.searchInput && this.initialId != undefined && !this.multiSelection && this.filteredItems && this.filteredItems.length > 0 ) {
          for ( let [key, item] of Object.entries(this.filteredItems) ) {
            if ( this.initialId == item[this.keyColumn] ) {
              this.$.itemsList.selectItem( this.$.itemsList.items[key] );
              this._selectedItems = this.lastSelectedItems = JSON.parse(JSON.stringify( this.ironListSelectedItems ));
              this.initialId = undefined;
              this._setValueInInput();
              break;
            }
          }
        }
      }

      _resizeItemListWidth () {
        if ( this.listWidth != undefined ) {
          this.$.dropdown.style.width = this.listWidth;
        } else if ( this.items && this.items.length > 0 ) {
          if ( this.fixedContainerWidth && this.targetElement ) {
            this.$.dropdown.style.width = this.targetElement.offsetWidth + 'px';
          } else {
            const longestItem = this.items.reduce( (a, b) => a[this.itemColumn].length > b[this.itemColumn].length ? a : b );
            // this._measureCanvas = this._measureCanvas || document.createElement('canvas');
            /*const listItems = this.$.itemsList.shadowRoot.querySelector('#items').querySelector('slot').assignedNodes();
            const listItemElement = listItems.find((e) => {
              return ( e.childNodes.length > 0 && e.lastElementChild.classList.contains('listItem') );
            });
            this._measureCanvas.font = window.getComputedStyle(listItemElement).font;*/
            this.$.dropdown.style.width = Math.max(this.targetElement.offsetWidth, longestItem[this.itemColumn].length * this.listItemWidth) + 'px';
          }
        } else if ( this.targetElement ) {
          this.$.dropdown.style.width = this.targetElement.offsetWidth + 'px';
        }
      }

      _selectItems () {
        if ( this.filteredItems && this.filteredItems.length > 0 && this._selectedItems && ( !this.multiSelection || this._selectedItems.length > 0 )) {
          for ( let [key, item] of Object.entries(this.filteredItems) ) {
            if ( !this.multiSelection ) {
              if ( this._selectedItems[this.keyColumn] == item[this.keyColumn] ) {
                this.$.itemsList.selectItem( this.$.itemsList.items[key] );
              }
            } else {
              for ( let selItem of this._selectedItems ) {
                if ( selItem[this.keyColumn] == item[this.keyColumn] ) {
                  this.$.itemsList.selectItem( this.$.itemsList.items[key] );
                }
              }
            }
          }
        }
      }

      _setValue () {
        if ( this.disabled ) {
          this.value = '';
        } else {
          if ( this.multiSelection ) {
            this.value = this._selectedItems ? this._selectedItems.map(item => item[this.keyColumn]).join(this.multiSelectionValueSeperator) : '';
          } else {
            this.value = this._selectedItems ? this._selectedItems[this.keyColumn] : '';
          }
        }
      }

      get selectedItems () {
        return this.disabled ? null : this._selectedItems;
      }

      _highlightTemplate () {
        return { begin: `<${this.highlightTemplateTag} class="${this.highlightTtemplateClass}">`, end: `</${this.highlightTemplateTag}>` };
      }

      _simpleArrayEqual (arr1, arr2) {
        if ( arr1.length != arr2.length ) {
          return false;
        }
        for ( let i = 0, l=arr1.length; i < l; i++ ) {
          if ( arr1[i] != arr2[i] ) {
            return false;
          }
        }
        return true;
      }

      _mergeOverlappedRanges (ranges) {
        let result = [], last;
        ranges.sort((a, b) => a[0]-b[0] || a[1]-b[1]);
        ranges.forEach(r => {
          if ( !last || (r[0] - 1) > last[1] ) {
            result.push(last = r);
          } else if ( (r[1] - 1) > last[1] ) {
            last[1] = r[1];
          }
        });
        return result;
      }

    }

  window.customElements.define(CasperSelect.is, CasperSelect);
  </script>
</dom-module>
